.\" fk(1) man page â€” meant to be read, not endured
.TH FK 1 "February 2026" "fk 0.1.0" "User Commands"
.
.SH NAME
fk \(em filter-kernel: a modern awk for humans
.
.SH SYNOPSIS
.B fk
.RB [ \-F\~\fIsep\fR ]
.RB [ \-f\~\fIprogfile\fR ]
.RB [ \-v\~\fIvar\fR = \fIval\fR ]
.RB [ \-i\~\fIcsv\fR | \fItsv\fR | \fIjson\fR | \fIparquet\fR ]
.RB [ \-H ]
.IR program\~
.RI [ file\~ .\|.\|.]
.br
.B fk
.RB [ options ]
.IR file\~ .\|.\|.
.br
.B fk \-\-describe
.RI [ file\~ .\|.\|.]
.br
.B fk \-\-suggest
.RI [ file\~ .\|.\|.]
.br
.B fk \-\-repl
.
.\" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
.SH QUICK START
.
You probably want one of these.
.
.TP
Print a column
.nf
\fBfk '{ print $2 }' data.txt\fR
.fi
.
.TP
Filter lines
.nf
\fBfk '/error/ { print NR, $0 }' log.txt\fR
.fi
.
.TP
Sum a column
.nf
\fBfk '{ s += $1 } END { print s }' numbers.txt\fR
.fi
.
.TP
View a CSV file
.nf
\fBfk data.csv\fR
\fBfk \-H \-v 'OFS=\\t' data.csv\fR
.fi
.
.TP
Process CSV
.nf
\fBfk \-i csv \-H '{ print $1, $3 }' report.csv\fR
.fi
.
.TP
Dig into JSON
.nf
\fBfk '{ print jpath($0, ".users[].name") }' data.json\fR
.fi
.
.TP
Describe unknown data
.nf
\fBfk \-\-describe mystery.csv.gz\fR
.fi
.
.PP
Read on for the full picture.
.
.\" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
.SH DESCRIPTION
.
\fBfk\fR reads input line by line (or record by record),
splits each record into fields,
tests it against your patterns,
and runs the matching actions.
Think of it as awk rebuilt in Rust with modern extras:
CSV/JSON input, unicode-aware strings, JSON path queries,
and negative field indexes.
.
.PP
If no files are given, \fBfk\fR reads stdin.
A filename of \fB\-\fR also means stdin.
.
.PP
\fBFile-only mode:\fR when all positional arguments are existing files
(detected by the presence of \fB/\fR or \fB.\fR in the name), the program
defaults to \fB{ print }\fR.
This makes \fBfk data.csv\fR work as a quick viewer.
Fields from structured readers (CSV, TSV, JSON) are joined by \fBOFS\fR
(default: space); use \fB\-v 'OFS=\\t'\fR for tab output or
\fB\-v 'OFS=,'\fR to preserve CSV.
.
.\" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
.SH OPTIONS
.
.TP
\fB\-F\fR \fIsep\fR
Set the field separator.
Default is whitespace (runs of spaces/tabs, leading/trailing trimmed).
A single character splits on that character exactly.
.
.TP
\fB\-f\fR \fIprogfile\fR
Read the program from a file instead of the command line.
If both \fB\-f\fR and an inline program are given, the inline argument
becomes a file operand.
.
.TP
\fB\-v\fR \fIvar\fR=\fIval\fR
Assign a variable before the program runs.
C-style escape sequences in the value are interpreted:
\fB\\t\fR (tab), \fB\\n\fR (newline), \fB\\r\fR, \fB\\a\fR, \fB\\b\fR, \fB\\f\fR,
\fB\\v\fR, \fB\\\\\fR, \fB\\"\fR, \fB\\xHH\fR, \fB\\uHHHH\fR.
Can be repeated.
.
.TP
\fB\-i\fR \fImode\fR
Input format.
\fBcsv\fR reads RFC\ 4180 CSV (quoted fields, embedded commas and newlines).
\fBtsv\fR reads tab-delimited (with quoting).
\fBjson\fR reads one JSON object per line; top-level values become fields.
The raw JSON line is preserved in \fB$0\fR so \fBjpath($0, ...)\fR works
in JSON mode.
\fBparquet\fR reads Apache Parquet files (columnar binary format).
Requires building with \fB\-\-features parquet\fR.
Column names become headers automatically.
.
.TP
\fB\-H\fR
Header mode.
The first record is consumed as column names and stored in the
\fBHDR\fR array (both \fBHDR[1]\fR=\fIname\fR and \fBHDR["name"]\fR=\fI1\fR).
Additionally, each column name is set as a variable equal to its
column index, so \fB$name\fR resolves to the right field.
Subsequent records are numbered from 1.
Parquet mode (\fB\-i parquet\fR) enables header mode automatically.
.
.TP
\fB\-d\fR, \fB\-\-describe\fR
Describe mode.
Sniff the input to detect format (CSV, TSV, JSON, whitespace), infer column
names and types, and show a few example \fBfk\fR programs.
Works with files and stdin; supports compressed files (.gz, .zst, .bz2, .xz).
.
.TP
\fB\-S\fR, \fB\-\-suggest\fR
Suggest mode.
Like \fB\-\-describe\fR, but adds a curated set of smart, copy\-pasteable
\fBfk\fR programs tailored to the data.  Picks the best category column
(lowest cardinality), uses real values and thresholds from the sample rows.
Typically produces 3\-6 suggestions covering filtering, aggregation,
group-by, statistics, and unique values.
.
.TP
\fB\-\-highlight\fR
Print a syntax\-highlighted version of the program and exit.
.
.TP
\fB\-\-format\fR
Pretty\-print the program with indentation and line breaks, then exit.
.
.TP
\fB\-\-repl\fR
Start an interactive session.
Each line you type is parsed and executed immediately.
State persists across lines.
Type \fB:q\fR to quit, \fB:vars\fR to inspect, \fB:reset\fR to clear.
.
.TP
\fB\-h\fR, \fB\-\-help\fR
Print a usage summary and exit.
.
.TP
\fB\-\-version\fR
Print the version number and exit.
.
.\" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
.SH INPUT MODE PRECEDENCE
.
When opening files, \fBfk\fR determines the input mode as follows:
.
.IP 1. 4
\fB\-i\fR (explicit) always wins.
Combining \fB\-F\fR with \fB\-i\fR is an error.
.IP 2. 4
\fB\-F\fR (explicit field separator) forces line mode.
Auto-detection from file extensions is skipped.
.IP 3. 4
\fBAuto-detection\fR from the first file's extension:
\fB.csv\fR \(-> CSV, \fB.tsv\fR/\fB.tab\fR \(-> TSV,
\fB.json\fR/\fB.jsonl\fR/\fB.ndjson\fR \(-> JSON,
\fB.parquet\fR \(-> Parquet.
Compression wrappers (\fB.gz\fR, \fB.zst\fR, \fB.bz2\fR, \fB.xz\fR, \fB.lz4\fR)
are stripped before matching.
.IP 4. 4
Default: line mode with whitespace splitting.
.
.\" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
.SH PROGRAM STRUCTURE
.
A program is one or more \fIrules\fR, each with an optional pattern and
an action in braces.
.
.PP
.nf
\fBBEGIN     { \fR\fI...runs once before input...\fR\fB }\fR
\fB/regex/   { \fR\fI...runs when the line matches...\fR\fB }\fR
\fB$3 > 100  { \fR\fI...runs when expression is true...\fR\fB }\fR
\fB          { \fR\fI...no pattern = runs every line...\fR\fB }\fR
\fBEND       { \fR\fI...runs once after all input...\fR\fB }\fR
.fi
.
.PP
Patterns can be combined:
.nf
\fB$1 == "x" && $2 ~ /foo/    { ... }\fR      compound
\fB/start/,/stop/              { ... }\fR      range (inclusive)
.fi
.
.\" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
.SH FIELDS
.
Each record is split into fields.
\fB$0\fR is the whole record.
\fB$1\fR, \fB$2\fR, etc. are individual fields.
\fB$NF\fR is the last field.
.
.PP
\fBfk extensions:\fR
.TP
\fB$\-1\fR
Last field.
\fB$\-2\fR is second-to-last, and so on.
.TP
\fB$(expr)\fR
Computed field access.
Example: \fB$(NF \- 1)\fR for the second-to-last field.
.TP
\fB$"column\-name"\fR
Named column access.
When in header mode (\fB\-H\fR or \fB\-i parquet\fR), any \fB$expr\fR that
evaluates to a non-numeric string is looked up in the \fBHDR\fR array.
Works with any column name, including those with hyphens, spaces, or dots.
.nf
\fB$"user\-name"\fR             # string literal
\fBcol = "revenue"; print $col\fR  # variable
.fi
.
.\" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
.SH VARIABLES
.
.TS
l l.
\fBNR\fR	Record number (across all files)
\fBNF\fR	Number of fields in current record
\fBFNR\fR	Record number in current file (resets per file)
\fBFILENAME\fR	Name of the current input file
\fBFS\fR	Input field separator (default: whitespace)
\fBOFS\fR	Output field separator (default: space)
\fBRS\fR	Record separator (default: newline; multi-char = regex)
\fBORS\fR	Output record separator (default: newline)
\fBSUBSEP\fR	Subscript separator for multi-dim arrays (default: \fB\\034\fR)
\fBOFMT\fR	Number output format (default: \fB"%.6g"\fR)
\fBRSTART\fR	Start of last \fBmatch()\fR hit
\fBRLENGTH\fR	Length of last \fBmatch()\fR hit
\fBENVIRON\fR	Array of environment variables (read-only)
\fBARGC\fR	Number of command-line arguments
\fBARGV\fR	Array of command-line arguments
.TE
.
.PP
Uninitialized variables are \fB""\fR in string context and \fB0\fR in numeric context.
.
.\" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
.SH OPERATORS
.
Listed by precedence (highest first):
.
.PP
.TS
l l.
\fB$\fR	Field access
\fB++ \-\-\fR	Increment / decrement
\fB**\fR	Exponentiation (right-associative) \fI[fk]\fR
\fB!\fR	Logical not
\fB* / %\fR	Multiply, divide, modulo
\fB+ \-\fR	Add, subtract
\fI(space)\fR	String concatenation
\fB< <= > >= == !=\fR	Comparison
\fB~ !~\fR	Regex match / not-match
\fB&&\fR	Logical and
\fB||\fR	Logical or
\fB?:\fR	Ternary
\fB= += \-= *= /= %=\fR	Assignment
.TE
.
.\" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
.SH CONTROL FLOW
.
.nf
\fBif\fR (cond) { ... } \fBelse\fR { ... }
\fBwhile\fR (cond) { ... }
\fBdo\fR { ... } \fBwhile\fR (cond)
\fBfor\fR (init; cond; step) { ... }
\fBfor\fR (key \fBin\fR array) { ... }
\fBbreak\fR   \fBcontinue\fR
\fBnext\fR                              skip to next record
\fBexit\fR [\fIcode\fR]                      run END block, then exit
\fBnextfile\fR                         skip to next input file \fI[fk]\fR
.fi
.
.\" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
.SH OUTPUT
.
.TP
\fBprint\fR \fIexpr\fR, \fIexpr\fR
Print values separated by OFS, terminated by ORS.
.TP
\fBprintf\fR \fIfmt\fR, \fIargs\fR
Formatted output (C-style).
No trailing newline.
Supports flags: \fB\-\fR (left-align), \fB0\fR (zero-pad),
\fB+\fR (force sign), \fI(space)\fR (space before positive numbers).
Conversions: \fB%d %i %f %e %g %s %c %x %o %%\fR.
.TP
\fBsprintf(\fIfmt\fR, \fIargs\fR)\fR
Like printf but returns a string instead of printing.
.
.PP
Redirect output:
.nf
print ... \fB>\fR  "file"          overwrite
print ... \fB>>\fR "file"          append
print ... \fB|\fR  "command"       pipe
print ... \fB>\fR  "/dev/stderr"   stderr
.fi
.
.\" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
.SH FUNCTIONS
.
.SS Strings
.
All string functions are unicode-aware: they count characters, not bytes.
.
.TP
\fBlength(\fIs\fB)\fR
Number of characters.
Also works on arrays: \fBlength(arr)\fR returns the element count.
.TP
\fBsubstr(\fIs\fB,\fR \fIstart\fR [\fB,\fR \fIlen\fR]\fB)\fR
Substring starting at position \fIstart\fR (1-indexed).
.TP
\fBindex(\fIs\fB,\fR \fItarget\fB)\fR
Position of \fItarget\fR in \fIs\fR, or 0 if not found.
.TP
\fBtolower(\fIs\fB)\fR / \fBtoupper(\fIs\fB)\fR
Case conversion.
.TP
\fBsub(\fIpat\fB,\fR \fIrepl\fR [\fB,\fR \fItarget\fR]\fB)\fR
Replace first match of \fIpat\fR. Returns 0 or 1.
Default target is \fB$0\fR.
.TP
\fBgsub(\fIpat\fB,\fR \fIrepl\fR [\fB,\fR \fItarget\fR]\fB)\fR
Replace all matches. Returns replacement count.
.TP
\fBmatch(\fIs\fB,\fR \fIpat\fR [\fB,\fR \fIarr\fR]\fB)\fR
Test \fIs\fR against \fIpat\fR.
Sets \fBRSTART\fR and \fBRLENGTH\fR.
Returns the start position, or 0.
If \fIarr\fR is given, \fIarr\fR[0] = full match,
\fIarr\fR[1], \fIarr\fR[2], ... = capture groups. \fI[fk extension]\fR
.TP
\fBsplit(\fIs\fB,\fR \fIarr\fR [\fB,\fR \fIsep\fR]\fB)\fR
Split \fIs\fR into \fIarr\fR[1], \fIarr\fR[2], etc.
Returns the element count.
.TP
\fBtrim(\fIs\fB)\fR / \fBltrim(\fIs\fB)\fR / \fBrtrim(\fIs\fB)\fR
Strip leading/trailing whitespace. \fI[fk]\fR
.TP
\fBstartswith(\fIs\fB,\fR \fIprefix\fB)\fR / \fBendswith(\fIs\fB,\fR \fIsuffix\fB)\fR
Returns 1 if \fIs\fR starts/ends with the given string, 0 otherwise. \fI[fk]\fR
.TP
\fBrepeat(\fIs\fB,\fR \fIn\fB)\fR
Repeat string \fIs\fR \fIn\fR times. \fI[fk]\fR
.TP
\fBreverse(\fIs\fB)\fR
Reverse a string (unicode-aware). \fI[fk]\fR
.TP
\fBchr(\fIn\fB)\fR / \fBord(\fIs\fB)\fR
Convert between character and codepoint. \fI[fk]\fR
.TP
\fBhex(\fIn\fB)\fR
Format a number as hexadecimal (e.g. \fB0xff\fR). \fI[fk]\fR
.TP
\fBlpad(\fIs\fB,\fR \fIwidth\fR [\fB,\fR \fIchar\fR]\fB)\fR
Left-pad \fIs\fR to \fIwidth\fR characters (default pad: space).
Never truncates. \fI[fk]\fR
.TP
\fBrpad(\fIs\fB,\fR \fIwidth\fR [\fB,\fR \fIchar\fR]\fB)\fR
Right-pad \fIs\fR to \fIwidth\fR characters (default pad: space).
Never truncates. \fI[fk]\fR
.
.SS Math
.TP
\fBint(\fIx\fB)\fR
Truncate to integer.
.TP
\fBsqrt(\fIx\fB)\fR, \fBsin(\fIx\fB)\fR, \fBcos(\fIx\fB)\fR, \fBlog(\fIx\fB)\fR, \fBexp(\fIx\fB)\fR
The usual suspects.
.TP
\fBabs(\fIx\fB)\fR
Absolute value. \fI[fk]\fR
.TP
\fBceil(\fIx\fB)\fR / \fBfloor(\fIx\fB)\fR / \fBround(\fIx\fB)\fR
Rounding. \fI[fk]\fR
.TP
\fBmin(\fIa\fB,\fR \fIb\fB)\fR / \fBmax(\fIa\fB,\fR \fIb\fB)\fR
Minimum / maximum of two values. \fI[fk]\fR
.TP
\fBatan2(\fIy\fB,\fR \fIx\fB)\fR
Arc tangent of \fIy\fR/\fIx\fR.
.TP
\fBlog2(\fIx\fB)\fR / \fBlog10(\fIx\fB)\fR
Base-2 and base-10 logarithm. \fI[fk]\fR
.TP
\fBrand()\fR
Random number between 0 and 1.
.TP
\fBsrand(\fR[\fIseed\fR]\fB)\fR
Seed the RNG. Returns previous seed.
.
.SS Time \fI[fk extensions]\fR
.TP
\fBsystime()\fR
Current time as seconds since epoch.
.TP
\fBstrftime(\fIfmt\fB,\fR \fIepoch\fB)\fR
Format an epoch timestamp.
Supports \fB%Y %m %d %H %M %S %A %B %a %b %j %u %w %e %C %y %p %I\fR.
.TP
\fBmktime("\fIY M D H M S\fB")\fR
Convert a date string back to epoch.
.TP
\fBparsedate(\fIstr\fB,\fR \fIfmt\fB)\fR
Parse a date string using the same \fB%Y %m %d %H %M %S\fR specifiers
as strftime. Returns epoch seconds. \fI[fk]\fR
.
.SS I/O
.TP
\fBsystem(\fIcmd\fB)\fR
Run a shell command. Returns its exit status.
.TP
\fBfflush()\fR
Flush stdout.
.TP
\fBclose(\fIname\fB)\fR
Close an output file or pipe opened by redirection.
Returns 0 on success, \-1 if not found.
.TP
\fBslurp(\fIfile\fB)\fR
Read the entire contents of \fIfile\fR and return as a string.
Use \fB"-"\fR or \fB"/dev/stdin"\fR to read from standard input. \fI[fk]\fR
.TP
\fBslurp(\fIfile\fB,\fR \fIarr\fB)\fR
Read \fIfile\fR line by line into \fIarr\fR[1], \fIarr\fR[2], etc.
Returns the line count. Accepts \fB"-"\fR for stdin. \fI[fk]\fR
.
.SS String replacement
.TP
\fBgensub(\fIregex\fB,\fR \fIrepl\fB,\fR \fIhow\fR [\fB,\fR \fItarget\fR]\fB)\fR
Like \fBgsub\fR but returns the modified string without changing the target.
\fIhow\fR can be \fB"g"\fR for global, or a number \fIN\fR to replace the
\fIN\fRth occurrence.
Default target is \fB$0\fR.
.
.SS Arrays \fI[fk extensions]\fR
.TP
\fBprint\fR \fIarr\fR
Print array contents, one entry per line (separated by ORS).
If the array has sequential integer keys (1..N), prints \fBvalues\fR
in order; otherwise prints \fBkeys\fR sorted.
This makes \fB{ u[$1]++ } END { print u }\fR print sorted unique values.
.TP
\fBkeys(\fIarr\fB)\fR
Return all keys as a string, sorted and joined by ORS. \fI[fk]\fR
.TP
\fBvals(\fIarr\fB)\fR
Return all values as a string, sorted by key and joined by ORS. \fI[fk]\fR
.TP
\fBasort(\fIarr\fB)\fR
Sort array by values, re-key with 1..N. Returns element count.
.TP
\fBasorti(\fIarr\fB)\fR
Sort array by keys, store sorted keys as values with 1..N.
.TP
\fBjoin(\fIarr\fR [\fB,\fR \fIsep\fR]\fB)\fR
Join array values into a string, separated by \fIsep\fR (default: OFS).
Numeric keys are joined in order.
.TP
\fBuniq(\fIarr\fB)\fR
Deduplicate values, re-key as 1..N. Returns new count.
.TP
\fBinv(\fIarr\fB)\fR
Swap keys and values in place. Returns count.
.TP
\fBtidy(\fIarr\fB)\fR
Remove entries with empty or zero values. Returns remaining count.
.TP
\fBshuf(\fIarr\fB)\fR
Randomize order, re-key as 1..N. Returns count.
.TP
\fBdiff(\fIa\fB,\fR \fIb\fB)\fR
Set difference: remove from \fIa\fR any key present in \fIb\fR.
Returns remaining count of \fIa\fR.
.TP
\fBinter(\fIa\fB,\fR \fIb\fB)\fR
Set intersection: remove from \fIa\fR any key not in \fIb\fR.
Returns remaining count of \fIa\fR.
.TP
\fBunion(\fIa\fB,\fR \fIb\fB)\fR
Set union: copy keys from \fIb\fR into \fIa\fR (without overwriting).
Returns total count of \fIa\fR.
.TP
\fBseq(\fIarr\fB,\fR \fIfrom\fB,\fR \fIto\fB)\fR
Fill \fIarr\fR with integers from \fIfrom\fR to \fIto\fR, keyed 1..N.
Direction is automatic. Returns count.
.TP
\fBsamp(\fIarr\fB,\fR \fIn\fB)\fR
Keep \fIn\fR random elements, re-key as 1..\fIn\fR.
Uses Fisher\-Yates partial shuffle. Returns \fIn\fR.
.
.SS Statistics \fI[fk extensions]\fR
.PP
All statistics functions take an array as the first argument and operate
on the numeric values in that array.
.TP
\fBsum(\fIarr\fB)\fR
Sum of all values.
.TP
\fBmean(\fIarr\fB)\fR
Arithmetic mean.
.TP
\fBmedian(\fIarr\fB)\fR
Median value (50th percentile).
.TP
\fBstddev(\fIarr\fB)\fR
Population standard deviation.
.TP
\fBvariance(\fIarr\fB)\fR
Population variance.
.TP
\fBhist(\fIarr\fB [\fB,\fR \fIbins\fR [\fB,\fR \fIout\fR [\fB,\fR \fImin\fR [\fB,\fR \fImax\fR]]]]]\fR
Histogram counts. Writes counts into \fIout\fR (or auto-generated array),
keys 1..bins. Bins default to Sturges' rule. Returns the output array
name, enabling chaining: \fBplotbox(hist(a))\fR. Metadata is stored
internally as a typed enum (not in the array).
.TP
\fBp(\fIarr\fB,\fR \fIn\fB)\fR / \fBpercentile(\fIarr\fB,\fR \fIn\fB)\fR
\fIn\fRth percentile (0\(en100). Uses linear interpolation.
.TP
\fBquantile(\fIarr\fB,\fR \fIq\fB)\fR
Same as percentile but \fIq\fR is 0\(en1 (e.g. 0.95 for p95).
.TP
\fBiqm(\fIarr\fB)\fR
Interquartile mean \(em mean of values between the 25th and 75th percentiles.
Robust against outliers.
.TP
\fBmin(\fIarr\fB)\fR / \fBmax(\fIarr\fB)\fR
Minimum / maximum value in the array.
(With two scalar arguments, returns the min/max of those two values.)
.
.SS Utility \fI[fk extensions]\fR
.TP
\fBtypeof(\fIx\fB)\fR
Returns \fB"number"\fR, \fB"string"\fR, \fB"array"\fR, or \fB"uninitialized"\fR.
.TP
\fBplot(\fIarr\fB [\fB,\fR \fIwidth\fR [\fB,\fR \fIchar\fR [\fB,\fR \fIprecision\fR [\fB,\fR \fIcolor\fR]]]]])\fR
Render a simple horizontal bar chart from array values. Accepts an array
name or a string returned by \fBhist()\fR. Auto-detects histogram metadata
for range labels. \fIcolor\fR: \fBred\fR, \fBgreen\fR, \fByellow\fR,
\fBblue\fR, \fBmagenta\fR, \fBcyan\fR, \fBgray\fR, or \fBnone\fR.
.TP
\fBplotbox(\fIarr\fB [\fB,\fR \fIwidth\fR [\fB,\fR \fIchar\fR [\fB,\fR \fIprecision\fR [\fB,\fR \fItitle\fR [\fB,\fR \fIxlabel\fR [\fB,\fR \fIcolor\fR]]]]]]])\fR
Boxed horizontal bar chart with optional title/x-label and color.
.
.SS Bitwise \fI[fk extensions]\fR
.TP
\fBand(\fIa\fB,\fR \fIb\fB)\fR / \fBor(\fIa\fB,\fR \fIb\fB)\fR / \fBxor(\fIa\fB,\fR \fIb\fB)\fR
Bitwise AND, OR, XOR.
.TP
\fBlshift(\fIa\fB,\fR \fIn\fB)\fR / \fBrshift(\fIa\fB,\fR \fIn\fB)\fR
Bit shift left / right.
.TP
\fBcompl(\fIa\fB)\fR
Bitwise complement.
.
.SS JSON \fI[fk extensions]\fR
.TP
\fBjpath(\fIjson\fB,\fR \fIpath\fB)\fR
Navigate into a JSON string and return the value at \fIpath\fR.
.TP
\fBjpath(\fIjson\fB,\fR \fIpath\fB,\fR \fIarr\fB)\fR
Same, but extract into an awk array.
Arrays become \fIarr\fR[1], \fIarr\fR[2], etc.
Objects become \fIarr\fR["key"].
Returns the element count.
.
.PP
Path syntax:
.nf
\fB.key\fR           object key
\fB[N]\fR            array index (0-based)
\fB.key.sub\fR       chained
\fB.arr[]\fR         iterate all elements
\fB.arr.key\fR       implicit iteration (= \fB.arr[].key\fR)
.fi
.
.PP
Example \(em get all user names from a nested structure:
.nf
\fBjpath($0, ".users[].name")\fR
.fi
.
.\" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
.SH ARRAYS
.
Arrays are associative (indexed by strings).
.
.nf
arr["key"] = value
x = arr["key"]
\fBdelete\fR arr["key"]          remove one element
\fBdelete\fR arr                  remove the entire array \fI[fk]\fR
\fBlength\fR(arr)                 element count \fI[fk]\fR
\fBfor\fR (k \fBin\fR arr) { ... }      iterate over keys
\fBif\fR ("key" \fBin\fR arr) { ... }   membership test
arr[i,j] = value              multi-dimensional (SUBSEP-joined key)
.fi
.
.\" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
.SH USER-DEFINED FUNCTIONS
.
.nf
\fBfunction\fR grade(score) {
    \fBif\fR (score >= 90) \fBreturn\fR "A"
    \fBif\fR (score >= 80) \fBreturn\fR "B"
    \fBreturn\fR "C"
}
{ print $1, grade($2) }
.fi
.
.PP
Parameters are local to the function.
Recursion works.
.
.\" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
.SH NUMERIC LITERALS
.
.nf
42          decimal
3.14        float
0xFF        hexadecimal \fI[fk]\fR
.fi
.
.\" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
.SH STRING ESCAPES
.
Inside double-quoted strings:
.
.nf
\\n  \\t  \\r  \\\\  \\"     standard
\\xHH                    hex byte \fI[fk]\fR
\\uHHHH                  unicode codepoint \fI[fk]\fR
.fi
.
.\" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
.SH EXAMPLES
.
These are meant to be stolen.
.
.SS The basics
.nf
# Second column of every line
\fBfk '{ print $2 }' file\fR

# Lines containing "error"
\fBfk '/error/' log.txt\fR

# Lines where column 3 exceeds 100
\fBfk '$3 > 100' data.txt\fR

# Sum column 1
\fBfk '{ s += $1 } END { print s }' numbers.txt\fR

# Average
\fBfk '{ s += $1 } END { print s / NR }' numbers.txt\fR

# Line count (like wc -l)
\fBfk 'END { print NR }' file\fR
.fi
.
.SS Filtering and transforming
.nf
# Unique values in column 2
\fBfk '!seen[$2]++' file\fR

# Remove blank lines
\fBfk 'NF > 0' file\fR

# Swap two columns
\fBfk '{ print $2, $1 }' file\fR

# Add line numbers
\fBfk '{ print NR, $0 }' file\fR

# Extract between two patterns
\fBfk '/START/,/END/' file\fR
.fi
.
.SS Counting and aggregation
.nf
# Frequency count of column 1
\fBfk '{ a[$1]++ } END { for (k in a) print a[k], k }' file\fR

# Group-by sum
\fBfk '{ sum[$1] += $2 } END { for (k in sum) print k, sum[k] }' file\fR

# Count lines matching a pattern
\fBfk '/error/ { c++ } END { print c+0 }' log.txt\fR
.fi
.
.SS CSV and structured data
.nf
# Read CSV, print two columns
\fBfk -i csv '{ print $1, $3 }' data.csv\fR

# CSV with headers â€” skip the header row automatically
\fBfk -i csv -H '{ print $1, $3 }' data.csv\fR

# Convert CSV to TSV
\fBfk -i csv -v 'OFS=\\t' '{ print $1, $2, $3 }' data.csv\fR

# JSON lines â€” filter by field
\fBfk -i json '$2 == "error" { print $1, $3 }' events.jsonl\fR

# Nested JSON â€” extract all IDs
\fBfk '{ print jpath($0, ".results[].id") }' response.json\fR

# JSON â€” aggregate into array
\fBfk '{ n=jpath($0,".items",a); for(i=1;i<=n;i++) print a[i] }' data.json\fR
.fi
.
.SS Parquet and named columns \fI[fk only]\fR
.nf
# Query a parquet file by column names
\fBfk -i parquet '$age > 30 { print $name, $city }' data.parquet\fR

# CSV with header names (same idea)
\fBfk -i csv -H '$status == "active" { print $email }' users.csv\fR

# Aggregate parquet data
\fBfk -i parquet '{ dept[$department] += $revenue }
END { for (d in dept) print d, dept[d] }' sales.parquet\fR

# Regex match with capture groups
\fBfk '{ match($0, "([0-9]+)-([A-Z]+)", cap); print cap[1], cap[2] }' file\fR

# Sort array values
\fBfk '{ a[$1]++ } END { asort(a); for (i=1; i in a; i++) print a[i] }' file\fR

# Join array into string
\fBfk 'BEGIN { a[1]="x"; a[2]="y"; a[3]="z"; print join(a, ",") }'\fR
.fi
.
.SS fk-only tricks
.nf
# Exponentiation
\fBfk '{ print $1 ** 2 }' numbers.txt\fR

# Last field
\fBfk '{ print $-1 }' file\fR

# Hex and unicode
\fBecho x | fk '{ printf "%d \\u2192 %c\\n", 0xCAFE, 0x41 }'\fR

# Timestamp the current time
\fBecho x | fk '{ print strftime("%Y-%m-%d %H:%M:%S", systime()) }'\fR
.fi
.
.\" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
.SH DIFFERENCES FROM AWK
.
\fBfk\fR is awk-compatible for the vast majority of programs.
Extensions marked \fI[fk]\fR above are additions, not changes.
Notably:
.
.IP \(bu 2
\fB**\fR exponentiation operator
.IP \(bu 2
\fB$\-1\fR, \fB$\-2\fR, ... for fields from the end
.IP \(bu 2
\fB0xFF\fR hex literals, \fB\\xHH\fR and \fB\\uHHHH\fR string escapes
.IP \(bu 2
\fBnextfile\fR statement
.IP \(bu 2
\fBdelete arr\fR (whole array) and \fBlength(arr)\fR
.IP \(bu 2
\fBsystime()\fR, \fBstrftime()\fR, \fBmktime()\fR, \fBparsedate()\fR
.IP \(bu 2
\fBjpath()\fR for JSON navigation
.IP \(bu 2
\fB\-i csv/tsv/json/parquet\fR, \fB\-H\fR header mode with named columns
.IP \(bu 2
\fB$"column\-name"\fR and \fB$var\fR named column access in header mode
.IP \(bu 2
\fBmatch()\fR with capture groups (3rd argument)
.IP \(bu 2
\fBprint arr\fR (smart array dump), \fBkeys()\fR, \fBvals()\fR,
\fBuniq()\fR, \fBinv()\fR, \fBtidy()\fR, \fBshuf()\fR, \fBsamp()\fR,
\fBdiff()\fR, \fBinter()\fR, \fBunion()\fR, \fBseq()\fR,
\fBasort()\fR, \fBasorti()\fR, \fBjoin()\fR, \fBtypeof()\fR
.IP \(bu 2
\fBsum()\fR, \fBmean()\fR, \fBmedian()\fR, \fBstddev()\fR, \fBvariance()\fR, \fBhist()\fR, \fBp()\fR, \fBiqm()\fR, \fBquantile()\fR
.IP \(bu 2
\fBtrim()\fR, \fBltrim()\fR, \fBrtrim()\fR, \fBstartswith()\fR, \fBendswith()\fR, \fBrepeat()\fR, \fBreverse()\fR, \fBlpad()\fR, \fBrpad()\fR
.IP \(bu 2
\fBabs()\fR, \fBceil()\fR, \fBfloor()\fR, \fBround()\fR, \fBmin()\fR, \fBmax()\fR, \fBlog2()\fR, \fBlog10()\fR
.IP \(bu 2
\fBchr()\fR, \fBord()\fR, \fBhex()\fR
.IP \(bu 2
Bitwise: \fBand()\fR, \fBor()\fR, \fBxor()\fR, \fBlshift()\fR, \fBrshift()\fR, \fBcompl()\fR
.IP \(bu 2
\fB\-\-repl\fR interactive mode
.IP \(bu 2
\fB\-\-describe\fR auto-detect format, infer schema, suggest programs
.IP \(bu 2
\fBslurp()\fR for reading files into strings or arrays
.IP \(bu 2
Transparent decompression of .gz, .zst, .bz2, .xz, .lz4 files
.IP \(bu 2
Auto-detect input mode from file extension (.csv \(-> \-i csv, etc.)
.IP \(bu 2
Unicode-aware string functions
.IP \(bu 2
Multi-char RS treated as regex
.
.\" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
.SH EXIT STATUS
.TP
.B 0
Success (or \fBexit\fR with no argument).
.TP
.B N
The code given to \fBexit(\fIN\fB)\fR in the program.
.TP
.B 1
Runtime error (I/O failure, etc.).
.TP
.B 2
Syntax or parse error in the program.
.
.\" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
.SH SEE ALSO
.BR awk (1),
.BR gawk (1),
.BR jq (1)
.
.PP
Cheat sheet: \fIdocs/cheatsheet.md\fR in the source tree.
.br
Examples: \fIexamples/\fR directory.
.
.\" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
.SH AUTHORS
.
Built as a learning exercise. Contributions welcome. ğŸŒ
\.
.TP
\fB\-\-highlight\fR
Print a syntax\-highlighted version of the program and exit.
Keywords, literals, and built\-ins are styled when output is a TTY.
\.
.TP
\fB\-\-format\fR
Pretty\-print the program with indentation and line breaks, then exit.
\.
