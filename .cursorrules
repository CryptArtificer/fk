# fk — filter-kernel: session handoff notes
#
# Read this first when resuming work on this project.

## What this is

A modernized awk clone in Rust called `fk` (filter-kernel). Built
incrementally as a learning exercise. The user values:
- Modularity and composability (no spaghetti)
- Commits in logical, coherent pieces
- Minimal dependencies (only `regex` crate so far; `criterion` for benchmarks)
- Never add co-author tags to commits — use `git commit-tree` plumbing

## Current state

- **~6,200 lines of Rust** across 22 source files
- **194 tests**, zero warnings, clippy clean
- **Phases 0–7 complete**
- Single dependency: `regex` crate
- Dev dependency: `criterion` (benchmarks)

## Architecture (read src/lib.rs for module list)

```
main.rs        — CLI dispatch, record loop
cli.rs         — argument parsing (-F, -f, -v, -i, -H, --repl)
lexer.rs       — tokenizer (Spanned tokens with line:col)
parser.rs      — recursive-descent → AST (Program, Rules, Exprs, Stmts)
action.rs      — executor: pattern matching, eval, statement dispatch
runtime.rs     — variables, fields, arrays
field.rs       — field splitting (FS semantics)
error.rs       — Span type for diagnostics
repl.rs        — interactive REPL (--repl)
input/mod.rs   — Record struct, RecordReader trait, multi-source orchestration
input/line.rs  — default newline reader
input/csv.rs   — RFC 4180 CSV/TSV reader
input/json.rs  — JSON Lines reader
input/regex_rs.rs — regex-based RS reader
builtins/mod.rs   — dispatch + coercion helpers (to_number, format_number)
builtins/string.rs — length, substr, index, tolower, toupper (unicode-aware)
builtins/math.rs   — int, sqrt, sin, cos, log, exp
builtins/printf.rs — format_printf
builtins/time.rs   — systime, strftime, mktime (pure UTC, no libc)
builtins/json.rs   — jpath() with JSON parser, path evaluator, iteration
```

## Key design decisions

- `RecordReader` trait returns `Record { text, fields: Option<Vec<String>> }`
  so structured readers (CSV/JSON) can pre-split fields
- Builtins that need runtime access (sub, gsub, split, close, gensub, jpath 3-arg, system)
  are special-cased in action.rs; pure builtins go through builtins::call_builtin
- Lexer produces `Spanned` tokens (token + Span); parser threads Span into errors
- Runtime stores everything as strings; to_number() coerces on demand (awk semantics)
- Built-in vars (NR, NF, FNR, FS, OFS, RS, ORS, SUBSEP, OFMT, FILENAME) are
  dedicated fields in Runtime, not in the HashMap; NR/NF/FNR stored as integers
- Executor owns a BufWriter<Stdout>; flushed at END, fflush(), and before system()
- Print writes parts directly to BufWriter (no intermediate String allocation)
- Recursion depth guard (MAX_CALL_DEPTH = 200) prevents stack overflow
- All string builtins are unicode-aware (chars, not bytes)
- jpath() supports multi-value navigation: .key[], .arr.key (implicit iteration)

## What's done (Phases 0–6)

Phase 0: CLI, I/O, field splitting, print, patterns, BEGIN/END, built-in vars
Phase 1: Expressions, assignment, control flow, arrays, printf, operators
Phase 2: User functions, getline, output redirect, sub/gsub/match/split, ranges, ternary
Phase 3a: Refactored builtins/, input/, error.rs
Phase 3b: CSV, TSV, JSON input modes, header mode (-H), RS regex, jpath()
Phase 3c: **, hex literals, \x/\u escapes, nextfile, delete arr, length(arr), $-1, system/fflush, time funcs
Phase 3d: Unicode-aware strings, REPL
Phase 4: Criterion benchmarks (field split, lex+parse, record processing), Makefile, comparison harness
Phase 5: 5 example scripts, cheat sheet, man page
Phase 6: Buffered stdout, interned built-in vars, zero-alloc print path,
  edge-case audit (15 new tests), recursion depth guard (limit 200),
  profile-guided executor optimisation, clippy clean
Phase 7: See dedicated section below

## What's done (Phase 7)

Phase 7: break/continue, do-while, next, exit/exit(code), -f flag, FILENAME,
  FNR, close(), ENVIRON, ARGC/ARGV, SUBSEP + multi-dim arrays, OFMT,
  computed regex, gensub(), proper regex::Regex for patterns and ~/!~

Key design decisions in Phase 7:
- Executor uses `Signal` enum (Return, Break, Continue, Exit) instead of
  `ReturnValue` struct — propagates through exec_block/exec_stmt/call_user_func
- `exit_code: Option<i32>` on Executor; checked by run_begin/run_record;
  END block still runs; main.rs propagates to process::exit()
- `next_record` flag (like `next_file`) — stops remaining rules for current record
- Regex patterns (`/pat/`, `~`, `!~`) use `regex::Regex` (not str::contains)
- Lexer preserves backslashes in regex literals for the regex engine
- FILENAME/FNR tracked in main.rs after next_record() (not before)
- `-f` flag: if both -f and inline program given, inline becomes file operand

### Remaining from Phase 6
- [ ] CI pipeline (build, test, lint, clippy)
- [ ] Publish to crates.io

### Performance (from `make bench-compare` on 1M lines, Apple M3 Pro):
fk is faster than awk (macOS system awk 20200816) on all 5 benchmarks:
- `print $2`: fk ~0.52s vs awk ~0.58s
- Sum/arithmetic: fk ~0.34s vs awk ~0.60s (fk 1.8× faster)
- Pattern matching: fk ~0.37s vs awk ~0.75s (fk 2× faster)
- Field arithmetic: fk ~0.34s vs awk ~0.62s (fk 1.8× faster)
- Associative arrays: fk ~0.43s vs awk ~0.66s (fk 1.5× faster)

## Tooling

- `make` — shows all targets
- `make test` / `make lint` / `make ci` — testing and linting
- `make bench` — criterion benchmarks
- `make bench-compare` — fk vs awk head-to-head (generates 1M-line CSV)
- `make man` — view the man page
- `make repl` — interactive mode

## Commit conventions

- Use `git commit-tree` to create commits (avoids hook-injected co-author tags)
- Pattern: `git add ... && TREE=$(git write-tree) && PARENT=$(git rev-parse HEAD) && COMMIT=$(echo "message" | GIT_AUTHOR_NAME="$(git config user.name)" GIT_AUTHOR_EMAIL="$(git config user.email)" GIT_COMMITTER_NAME="$(git config user.name)" GIT_COMMITTER_EMAIL="$(git config user.email)" git commit-tree "$TREE" -p "$PARENT") && git reset --soft "$COMMIT"`
- Never add co-author tags
- Commit in logical, coherent pieces (one feature or concern per commit)
